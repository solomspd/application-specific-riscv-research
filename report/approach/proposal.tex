\documentclass[]{article}

\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=1cm]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{code}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\definecolor{delim}{rgb}{0.5,0.5,0}
\definecolor{punct}{rgb}{0,0,0.5}
\definecolor{numb}{rgb}{0,0.5,0.5}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{backcolour},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstset{style=code}

\title{RISC-V approach proposal}
\author{Abdelsalam ElTamawy}


\begin{document}

	% \maketitle

	In essence what we are trying to do is breakup \verb|verilog| code and decidedly put it back together omitting certain parts of it depending on which instructions are used and which \verb|verilog| code is needed to support these instructions.

	First we create classify how each group-able block of \verb|verilog| code is used by each instruction. To communicate that with ourselves and each other, we can simply add comments to each block, or even line if need be, so that we can much more easily identify them.

	\begin{lstlisting}[language=verilog, caption=an example of an annotated file]
		`include "defines.v"

		module alu (
			input [31:0]a // ADD, SUB, SLL, SLT, XOR, OR, SRA, AND, ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRLI, SRAI
			, input [31:0]b // // ADD, SUB, SLL, SLT, XOR, OR, SRA, AND, ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRLI, SRAI
			, input [4:0]shamt // SLL, SLT, SLTU
			, output reg [31:0]out // all, requirement of the module
			, output cf 
			, input [3:0]alufn // ADD, SUB, SLL, SLT, XOR, OR, SRA, AND, ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRLI, SRAI
			);
		
			wire [31:0] add, op_b; // ADD, SUB
			
			assign op_b = (~b); // SUB
			
			assign {cf, add} = alufn[0] ? (a + op_b + 1'b1) : (a + b); // ADD, SUB
			
			assign vf = (a[31] ^ (op_b[31]) ^ add[31] ^ cf);
			
			wire[31:0] sh; // SLLI, SRLI, SRAI, SLL, SLT, SLTU
			shifter shifter0(.a(a), .shamt(shamt), .type(alufn[1:0]),  .r(sh)); // SLLI, SRLI, SRAI, SLL, SLT, SLTU
			
			always @ * begin
				out = 0;
				(* parallel_case *)
				case (alufn)
					// arithmetic
					`ALU_ADD : out = add;
					`ALU_SUB : out = add;
					`ALU_PASS : out = b;
					// logic
					`ALU_OR:  out = a | b;
					`ALU_AND:  out = a & b;
					`ALU_XOR:  out = a ^ b;
					// shift
					`ALU_SRL:  out=sh;
					`ALU_SRA:  out=sh;
					`ALU_SLL:  out=sh;
					// slt & sltu
					`ALU_SLT:  out = {31'b0,(sf != vf)};
					`ALU_SLTU:  out = {31'b0,(~cf)};
				endcase
			end
		endmodule
	\end{lstlisting}

	Now we have an easy way of immediately identifying code to instruction relations.
	With this classification, we can build a JSON file that represent this.

	\pagebreak
	\begin{lstlisting}[language=json,caption=example JSON]
	{
		"module": "ALU"
		"args": [
			{
				"type": "input", "length": 32, "name": "a",
				"instructions": ["ADD", "SUB", "SLL", "SLT", "XOR", "OR", "SRA", "AND", "ADDI", "SLTI", "SLTIU", "XORI", "ORI", "ANDI", "SLLI", "SRLI", "SRLI", "SRAI"]
			},
			{
				"type": "input", "length": 32, "name": "b",
				"instructions": ["ADD", "SUB", "SLL", "SLT", "XOR", "OR", "SRA", "AND", "ADDI", "SLTI", "SLTIU", "XORI", "ORI", "ANDI", "SLLI", "SRLI", "SRLI", "SRAI"]
			},
			{
				"type": "input", "length": 5, "name": "shamt",
				"instructions": ["SLL", "SLT", "SLTU"]
			},
			{
				"type": "output reg", "length": 32, "name": "out",
				"instructions": ["all"]
			},
			{
				"type": "input", "length": 1, "name": "cf",
				"instruction": ["all"]
			},
			{
				"type": "output", "length": 4, "name": "alufn",
				"instructions": ["ADD", "SUB", "SLL", "SLT", "XOR", "OR", "SRA", "AND", "ADDI", "SLTI", "SLTIU", "XORI", "ORI", "ANDI", "SLLI", "SRLI", "SRLI", "SRAI"]
			}
		]
		"declarations": [
			{
				"type": "wire", "length": 32, "name": "add"
				"instructions": ["ADD", "SUB"]
			},
			{
				"type": "wire", "length": 32, "name": "op_b",
				"instructions": ["SUB"]
			}
		]
		"always": [
			"trigger": "*",
			"case": {
				"condition": "alufn"
				"assigns": [
					{
						"code": "`ALU_ADD : out = add;",
						"req": ["ADD"]
					},
					{
						"code": "`ALU_SUB : out = add;",
						"req": ["SUB"]
					}
					...etc
				]
			}
		]
	}
	\end{lstlisting}

	Using this structure as well as a disjoint set, we can 

\end{document}