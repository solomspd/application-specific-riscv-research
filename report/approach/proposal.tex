\documentclass[]{article}

\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=1cm]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{code}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=code}

\title{RISC-V approach proposal}
\author{Abdelsalam ElTamawy}


\begin{document}

	% \maketitle

	In essence what we are trying to do is breakup \verb|verilog| code and decidedly put it back together omitting certain parts of it depending on which instructions are used and which \verb|verilog| code is needed to support these instructions.

	First we create classify how each group-able block of \verb|verilog| code is used by each instruction. To communicate that with ourselves and each other, we can simply add comments to each block, or even line if need be, so that we can much more easily identify them.

	\begin{lstlisting}[language=verilog]
		`include "defines.v"

		module alu (
			input [31:0]a // ADD, SUB, 
			, input [31:0]b
			, input [4:0]shamt // SLL, SLT, SLTU
			, output reg [31:0]out
			, output cf
			, output zf
			, output vf
			, output sf
			, input [3:0]alufn
			);
		
			wire [31:0] add, sub, op_b;
			wire cfa, cfs;
			
			assign op_b = (~b);
			
			assign {cf, add} = alufn[0] ? (a + op_b + 1'b1) : (a + b);
			
			assign zf = (add == 0);
			assign sf = add[31];
			assign vf = (a[31] ^ (op_b[31]) ^ add[31] ^ cf);
			
			wire[31:0] sh;
			shifter shifter0(.a(a), .shamt(shamt), .type(alufn[1:0]),  .r(sh));
			
			always @ * begin
				out = 0;
				(* parallel_case *)
				case (alufn)
					// arithmetic
					`ALU_ADD : out = add;
					`ALU_SUB : out = add;
					`ALU_PASS : out = b;
					// logic
					`ALU_OR:  out = a | b;
					`ALU_AND:  out = a & b;
					`ALU_XOR:  out = a ^ b;
					// shift
					`ALU_SRL:  out=sh;
					`ALU_SRA:  out=sh;
					`ALU_SLL:  out=sh;
					// slt & sltu
					`ALU_SLT:  out = {31'b0,(sf != vf)};
					`ALU_SLTU:  out = {31'b0,(~cf)};
				endcase
			end
		endmodule
	\end{lstlisting}


\end{document}